{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isRowMajor = require( '@stdlib/ndarray-base-assert-is-row-major-string' );\nvar isReadOnly = require( '@stdlib/ndarray-base-assert-is-read-only' );\nvar isSortedAscending = require( '@stdlib/array-base-assert-is-sorted-ascending' );\nvar toNormalizedIndices = require( '@stdlib/ndarray-base-to-unique-normalized-indices' );\nvar getDType = require( '@stdlib/ndarray-base-dtype' );\nvar getShape = require( '@stdlib/ndarray-base-shape' );\nvar getStrides = require( '@stdlib/ndarray-base-strides' );\nvar getOffset = require( '@stdlib/ndarray-base-offset' );\nvar getOrder = require( '@stdlib/ndarray-base-order' );\nvar getData = require( '@stdlib/ndarray-base-data-buffer' );\nvar ones = require( '@stdlib/array-base-ones' );\nvar zeros = require( '@stdlib/array-base-zeros' );\nvar format = require( '@stdlib/string-format' );\n\n\n// MAIN //\n\n/**\n* Expands the shape of an array to a specified dimensionality by spreading its dimensions to specified dimension indices and inserting dimensions of size one for the remaining dimensions.\n*\n* ## Notes\n*\n* -   Each provided dimension index must reside on the interval `[-ndims, ndims-1]`. If provided a negative dimension index, the position at which to place a respective dimension is computed as `ndims + index`.\n* -   Provided dimension indices must resolve to normalized dimension indices arranged in ascending order.\n*\n* @param {NonNegativeInteger} ndims - number of dimensions in the output array\n* @param {ndarray} x - input array\n* @param {IntegerArray} dims - dimension indices at which to spread array dimensions\n* @throws {RangeError} first argument must be greater than or equal to the number of dimensions in the input array\n* @throws {RangeError} must provide the same number of dimension indices as the number of dimensions in the input array\n* @throws {RangeError} must provide valid dimension indices\n* @throws {Error} must provide unique dimension indices\n* @throws {Error} dimension indices must resolve to normalized dimension indices arranged in ascending order\n* @returns {ndarray} output array\n*\n* @example\n* var array = require( '@stdlib/ndarray-array' );\n*\n* var x = array( [ [ 1, 2 ], [ 3, 4 ] ] );\n* // returns <ndarray>\n*\n* var shx = x.shape;\n* // returns [ 2, 2 ]\n*\n* var y = spreadDimensions( 5, x, [ 1, 3 ] );\n* // returns <ndarray>\n*\n* var shy = y.shape;\n* // returns [ 1, 2, 1, 2, 1 ]\n*\n* var v = y.get( 0, 0, 0, 0, 0 );\n* // returns 1\n*\n* v = y.get( 0, 0, 0, 1, 0 );\n* // returns 2\n*\n* v = y.get( 0, 1, 0, 0, 0 );\n* // returns 3\n*\n* v = y.get( 0, 1, 0, 1, 0 );\n* // returns 4\n*/\nfunction spreadDimensions( ndims, x, dims ) {\n\tvar strides;\n\tvar shape;\n\tvar isrm;\n\tvar ord;\n\tvar sh;\n\tvar st;\n\tvar d;\n\tvar S;\n\tvar s;\n\tvar i;\n\tvar j;\n\n\tsh = getShape( x, false );\n\tst = getStrides( x, false );\n\tord = getOrder( x );\n\tisrm = isRowMajor( ord );\n\n\tif ( sh.length > ndims ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument must be greater than or equal to the number of dimensions in the input ndarray. Number of dimensions: %d. Value: `%d`.', sh.length, ndims ) );\n\t}\n\t// Resolve dimension indices...\n\td = toNormalizedIndices( dims, ndims-1 );\n\tif ( d === null ) {\n\t\tthrow new RangeError( format( 'invalid argument. Specified dimension index is out-of-bounds. Must be on the interval: [-%u, %u]. Value: `[%s]`.', ndims, ndims-1, dims.join( ', ' ) ) );\n\t}\n\tif ( d.length !== dims.length ) {\n\t\tthrow new Error( format( 'invalid argument. Must provide unique dimension indices. Value: `[%s]`.', dims.join( ', ' ) ) );\n\t}\n\tif ( d.length !== sh.length ) {\n\t\tthrow new RangeError( format( 'invalid argument. Must provide the same number of dimension indices as the number of dimensions in the input ndarray. Number of dimensions: %d. Value: `[%s]`.', sh.length, dims.join( ', ' ) ) );\n\t}\n\tif ( d.length && !isSortedAscending( d ) ) {\n\t\tthrow new Error( format( 'invalid argument. Must provide dimension indices which resolve to nonnegative indices arranged in ascending order. Value: `[%s]`.', dims.join( ', ' ) ) );\n\t}\n\t// When provided a zero-dimensional array, every expanded dimension is a singleton dimension having zero stride...\n\tif ( sh.length === 0 ) {\n\t\tshape = ones( ndims );\n\t\tstrides = zeros( ndims );\n\t} else {\n\t\t// Interweave singleton dimensions...\n\t\tstrides = [];\n\t\tshape = [];\n\t\tj = 0;\n\t\tfor ( i = 0; i < ndims; i++ ) {\n\t\t\tif ( i === d[ j ] ) {\n\t\t\t\t// If we have a match, we can move on to inserting singleton dimensions before the next dimension index...\n\t\t\t\tS = sh[ j ];\n\t\t\t\ts = st[ j ];\n\t\t\t\tj += 1;\n\t\t\t} else if ( j === sh.length ) { // append\n\t\t\t\t// We should only get here after exhausting all the dimension indices...\n\t\t\t\tS = 1;\n\t\t\t\ts = st[ j-1 ];\n\t\t\t\tif ( !isrm ) {\n\t\t\t\t\ts *= sh[ j-1 ];\n\t\t\t\t}\n\t\t\t} else { // insert before\n\t\t\t\t// We have yet to reach the next specified dimension index so we insert a singleton dimension...\n\t\t\t\tS = 1;\n\t\t\t\ts = st[ j ];\n\t\t\t\tif ( isrm ) {\n\t\t\t\t\ts *= sh[ j ];\n\t\t\t\t}\n\t\t\t}\n\t\t\tshape.push( S );\n\t\t\tstrides.push( s );\n\t\t}\n\t}\n\tif ( isReadOnly( x ) ) {\n\t\t// If provided a read-only view, the returned array should also be read-only...\n\t\treturn new x.constructor( getDType( x ), getData( x ), shape, strides, getOffset( x ), ord, { // eslint-disable-line max-len\n\t\t\t'readonly': true\n\t\t});\n\t}\n\treturn new x.constructor( getDType( x ), getData( x ), shape, strides, getOffset( x ), ord ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nmodule.exports = spreadDimensions;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Expand the shape of an array to a specified dimensionality by spreading its dimensions to specified dimension indices and inserting dimensions of size one for the remaining dimensions.\n*\n* @module @stdlib/ndarray-base-spread-dimensions\n*\n* @example\n* var array = require( '@stdlib/ndarray-array' );\n* var spreadDimensions = require( '@stdlib/ndarray-base-spread-dimensions' );\n*\n* var x = array( [ [ 1, 2 ], [ 3, 4 ] ] );\n* // returns <ndarray>\n*\n* var shx = x.shape;\n* // returns [ 2, 2 ]\n*\n* var y = spreadDimensions( 5, x, [ 1, 3 ] );\n* // returns <ndarray>\n*\n* var shy = y.shape;\n* // returns [ 1, 2, 1, 2, 1 ]\n*\n* var v = y.get( 0, 0, 0, 0, 0 );\n* // returns 1\n*\n* v = y.get( 0, 0, 0, 1, 0 );\n* // returns 2\n*\n* v = y.get( 0, 1, 0, 0, 0 );\n* // returns 3\n*\n* v = y.get( 0, 1, 0, 1, 0 );\n* // returns 4\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "uGAAA,IAAAA,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAa,QAAS,iDAAkD,EACxEC,EAAa,QAAS,0CAA2C,EACjEC,EAAoB,QAAS,+CAAgD,EAC7EC,EAAsB,QAAS,mDAAoD,EACnFC,EAAW,QAAS,4BAA6B,EACjDC,EAAW,QAAS,4BAA6B,EACjDC,EAAa,QAAS,8BAA+B,EACrDC,EAAY,QAAS,6BAA8B,EACnDC,EAAW,QAAS,4BAA6B,EACjDC,EAAU,QAAS,kCAAmC,EACtDC,EAAO,QAAS,yBAA0B,EAC1CC,EAAQ,QAAS,0BAA2B,EAC5CC,EAAS,QAAS,uBAAwB,EAkD9C,SAASC,EAAkBC,EAAOC,EAAGC,EAAO,CAC3C,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAOJ,GALAN,EAAKhB,EAAUU,EAAG,EAAM,EACxBO,EAAKhB,EAAYS,EAAG,EAAM,EAC1BK,EAAMZ,EAAUO,CAAE,EAClBI,EAAOnB,EAAYoB,CAAI,EAElBC,EAAG,OAASP,EAChB,MAAM,IAAI,WAAYF,EAAQ,0JAA2JS,EAAG,OAAQP,CAAM,CAAE,EAI7M,GADAS,EAAIpB,EAAqBa,EAAMF,EAAM,CAAE,EAClCS,IAAM,KACV,MAAM,IAAI,WAAYX,EAAQ,mHAAoHE,EAAOA,EAAM,EAAGE,EAAK,KAAM,IAAK,CAAE,CAAE,EAEvL,GAAKO,EAAE,SAAWP,EAAK,OACtB,MAAM,IAAI,MAAOJ,EAAQ,0EAA2EI,EAAK,KAAM,IAAK,CAAE,CAAE,EAEzH,GAAKO,EAAE,SAAWF,EAAG,OACpB,MAAM,IAAI,WAAYT,EAAQ,iKAAkKS,EAAG,OAAQL,EAAK,KAAM,IAAK,CAAE,CAAE,EAEhO,GAAKO,EAAE,QAAU,CAACrB,EAAmBqB,CAAE,EACtC,MAAM,IAAI,MAAOX,EAAQ,oIAAqII,EAAK,KAAM,IAAK,CAAE,CAAE,EAGnL,GAAKK,EAAG,SAAW,EAClBH,EAAQR,EAAMI,CAAM,EACpBG,EAAUN,EAAOG,CAAM,MAMvB,KAHAG,EAAU,CAAC,EACXC,EAAQ,CAAC,EACTS,EAAI,EACED,EAAI,EAAGA,EAAIZ,EAAOY,IAClBA,IAAMH,EAAGI,CAAE,GAEfH,EAAIH,EAAIM,CAAE,EACVF,EAAIH,EAAIK,CAAE,EACVA,GAAK,GACMA,IAAMN,EAAG,QAEpBG,EAAI,EACJC,EAAIH,EAAIK,EAAE,CAAE,EACNR,IACLM,GAAKJ,EAAIM,EAAE,CAAE,KAIdH,EAAI,EACJC,EAAIH,EAAIK,CAAE,EACLR,IACJM,GAAKJ,EAAIM,CAAE,IAGbT,EAAM,KAAMM,CAAE,EACdP,EAAQ,KAAMQ,CAAE,EAGlB,OAAKxB,EAAYc,CAAE,EAEX,IAAIA,EAAE,YAAaX,EAAUW,CAAE,EAAGN,EAASM,CAAE,EAAGG,EAAOD,EAASV,EAAWQ,CAAE,EAAGK,EAAK,CAC3F,SAAY,EACb,CAAC,EAEK,IAAIL,EAAE,YAAaX,EAAUW,CAAE,EAAGN,EAASM,CAAE,EAAGG,EAAOD,EAASV,EAAWQ,CAAE,EAAGK,CAAI,CAC5F,CAKArB,EAAO,QAAUc,IC7GjB,IAAIe,EAAO,IAKX,OAAO,QAAUA",
  "names": ["require_main", "__commonJSMin", "exports", "module", "isRowMajor", "isReadOnly", "isSortedAscending", "toNormalizedIndices", "getDType", "getShape", "getStrides", "getOffset", "getOrder", "getData", "ones", "zeros", "format", "spreadDimensions", "ndims", "x", "dims", "strides", "shape", "isrm", "ord", "sh", "st", "d", "S", "s", "i", "j", "main"]
}
