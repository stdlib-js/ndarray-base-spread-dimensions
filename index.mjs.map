{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray-base-assert-is-row-major-string';\nimport isReadOnly from '@stdlib/ndarray-base-assert-is-read-only';\nimport isSortedAscending from '@stdlib/array-base-assert-is-sorted-ascending';\nimport toNormalizedIndices from '@stdlib/ndarray-base-to-unique-normalized-indices';\nimport getDType from '@stdlib/ndarray-base-dtype';\nimport getShape from '@stdlib/ndarray-base-shape';\nimport getStrides from '@stdlib/ndarray-base-strides';\nimport getOffset from '@stdlib/ndarray-base-offset';\nimport getOrder from '@stdlib/ndarray-base-order';\nimport getData from '@stdlib/ndarray-base-data-buffer';\nimport ones from '@stdlib/array-base-ones';\nimport zeros from '@stdlib/array-base-zeros';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// MAIN //\n\n/**\n* Expands the shape of an array to a specified dimensionality by spreading its dimensions to specified dimension indices and inserting dimensions of size one for the remaining dimensions.\n*\n* ## Notes\n*\n* -   Each provided dimension index must reside on the interval `[-ndims, ndims-1]`. If provided a negative dimension index, the position at which to place a respective dimension is computed as `ndims + index`.\n* -   Provided dimension indices must resolve to normalized dimension indices arranged in ascending order.\n*\n* @param {NonNegativeInteger} ndims - number of dimensions in the output array\n* @param {ndarray} x - input array\n* @param {IntegerArray} dims - dimension indices at which to spread array dimensions\n* @throws {RangeError} first argument must be greater than or equal to the number of dimensions in the input array\n* @throws {RangeError} must provide the same number of dimension indices as the number of dimensions in the input array\n* @throws {RangeError} must provide valid dimension indices\n* @throws {Error} must provide unique dimension indices\n* @throws {Error} dimension indices must resolve to normalized dimension indices arranged in ascending order\n* @returns {ndarray} output array\n*\n* @example\n* import array from '@stdlib/ndarray-array';\n*\n* var x = array( [ [ 1, 2 ], [ 3, 4 ] ] );\n* // returns <ndarray>\n*\n* var shx = x.shape;\n* // returns [ 2, 2 ]\n*\n* var y = spreadDimensions( 5, x, [ 1, 3 ] );\n* // returns <ndarray>\n*\n* var shy = y.shape;\n* // returns [ 1, 2, 1, 2, 1 ]\n*\n* var v = y.get( 0, 0, 0, 0, 0 );\n* // returns 1\n*\n* v = y.get( 0, 0, 0, 1, 0 );\n* // returns 2\n*\n* v = y.get( 0, 1, 0, 0, 0 );\n* // returns 3\n*\n* v = y.get( 0, 1, 0, 1, 0 );\n* // returns 4\n*/\nfunction spreadDimensions( ndims, x, dims ) {\n\tvar strides;\n\tvar shape;\n\tvar isrm;\n\tvar ord;\n\tvar sh;\n\tvar st;\n\tvar d;\n\tvar S;\n\tvar s;\n\tvar i;\n\tvar j;\n\n\tsh = getShape( x, false );\n\tst = getStrides( x, false );\n\tord = getOrder( x );\n\tisrm = isRowMajor( ord );\n\n\tif ( sh.length > ndims ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument must be greater than or equal to the number of dimensions in the input ndarray. Number of dimensions: %d. Value: `%d`.', sh.length, ndims ) );\n\t}\n\t// Resolve dimension indices...\n\td = toNormalizedIndices( dims, ndims-1 );\n\tif ( d === null ) {\n\t\tthrow new RangeError( format( 'invalid argument. Specified dimension index is out-of-bounds. Must be on the interval: [-%u, %u]. Value: `[%s]`.', ndims, ndims-1, dims.join( ', ' ) ) );\n\t}\n\tif ( d.length !== dims.length ) {\n\t\tthrow new Error( format( 'invalid argument. Must provide unique dimension indices. Value: `[%s]`.', dims.join( ', ' ) ) );\n\t}\n\tif ( d.length !== sh.length ) {\n\t\tthrow new RangeError( format( 'invalid argument. Must provide the same number of dimension indices as the number of dimensions in the input ndarray. Number of dimensions: %d. Value: `[%s]`.', sh.length, dims.join( ', ' ) ) );\n\t}\n\tif ( d.length && !isSortedAscending( d ) ) {\n\t\tthrow new Error( format( 'invalid argument. Must provide dimension indices which resolve to nonnegative indices arranged in ascending order. Value: `[%s]`.', dims.join( ', ' ) ) );\n\t}\n\t// When provided a zero-dimensional array, every expanded dimension is a singleton dimension having zero stride...\n\tif ( sh.length === 0 ) {\n\t\tshape = ones( ndims );\n\t\tstrides = zeros( ndims );\n\t} else {\n\t\t// Interweave singleton dimensions...\n\t\tstrides = [];\n\t\tshape = [];\n\t\tj = 0;\n\t\tfor ( i = 0; i < ndims; i++ ) {\n\t\t\tif ( i === d[ j ] ) {\n\t\t\t\t// If we have a match, we can move on to inserting singleton dimensions before the next dimension index...\n\t\t\t\tS = sh[ j ];\n\t\t\t\ts = st[ j ];\n\t\t\t\tj += 1;\n\t\t\t} else if ( j === sh.length ) { // append\n\t\t\t\t// We should only get here after exhausting all the dimension indices...\n\t\t\t\tS = 1;\n\t\t\t\ts = st[ j-1 ];\n\t\t\t\tif ( !isrm ) {\n\t\t\t\t\ts *= sh[ j-1 ];\n\t\t\t\t}\n\t\t\t} else { // insert before\n\t\t\t\t// We have yet to reach the next specified dimension index so we insert a singleton dimension...\n\t\t\t\tS = 1;\n\t\t\t\ts = st[ j ];\n\t\t\t\tif ( isrm ) {\n\t\t\t\t\ts *= sh[ j ];\n\t\t\t\t}\n\t\t\t}\n\t\t\tshape.push( S );\n\t\t\tstrides.push( s );\n\t\t}\n\t}\n\tif ( isReadOnly( x ) ) {\n\t\t// If provided a read-only view, the returned array should also be read-only...\n\t\treturn new x.constructor( getDType( x ), getData( x ), shape, strides, getOffset( x ), ord, { // eslint-disable-line max-len\n\t\t\t'readonly': true\n\t\t});\n\t}\n\treturn new x.constructor( getDType( x ), getData( x ), shape, strides, getOffset( x ), ord ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default spreadDimensions;\n"],"names":["spreadDimensions","ndims","x","dims","strides","shape","isrm","ord","sh","st","d","S","s","i","j","getShape","getStrides","getOrder","isRowMajor","length","RangeError","format","toNormalizedIndices","join","Error","isSortedAscending","ones","zeros","push","isReadOnly","constructor","getDType","getData","getOffset","readonly"],"mappings":";;mrCAoFA,SAASA,EAAkBC,EAAOC,EAAGC,GACpC,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAOJ,GALAN,EAAKO,EAAUb,GAAG,GAClBO,EAAKO,EAAYd,GAAG,GACpBK,EAAMU,EAAUf,GAChBI,EAAOY,EAAYX,GAEdC,EAAGW,OAASlB,EAChB,MAAM,IAAImB,WAAYC,EAAQ,0JAA2Jb,EAAGW,OAAQlB,IAIrM,GAAW,QADXS,EAAIY,EAAqBnB,EAAMF,EAAM,IAEpC,MAAM,IAAImB,WAAYC,EAAQ,mHAAoHpB,EAAOA,EAAM,EAAGE,EAAKoB,KAAM,QAE9K,GAAKb,EAAES,SAAWhB,EAAKgB,OACtB,MAAM,IAAIK,MAAOH,EAAQ,0EAA2ElB,EAAKoB,KAAM,QAEhH,GAAKb,EAAES,SAAWX,EAAGW,OACpB,MAAM,IAAIC,WAAYC,EAAQ,iKAAkKb,EAAGW,OAAQhB,EAAKoB,KAAM,QAEvN,GAAKb,EAAES,SAAWM,EAAmBf,GACpC,MAAM,IAAIc,MAAOH,EAAQ,oIAAqIlB,EAAKoB,KAAM,QAG1K,GAAmB,IAAdf,EAAGW,OACPd,EAAQqB,EAAMzB,GACdG,EAAUuB,EAAO1B,QAMjB,IAHAG,EAAU,GACVC,EAAQ,GACRS,EAAI,EACED,EAAI,EAAGA,EAAIZ,EAAOY,IAClBA,IAAMH,EAAGI,IAEbH,EAAIH,EAAIM,GACRF,EAAIH,EAAIK,GACRA,GAAK,GACMA,IAAMN,EAAGW,QAEpBR,EAAI,EACJC,EAAIH,EAAIK,EAAE,GACJR,IACLM,GAAKJ,EAAIM,EAAE,MAIZH,EAAI,EACJC,EAAIH,EAAIK,GACHR,IACJM,GAAKJ,EAAIM,KAGXT,EAAMuB,KAAMjB,GACZP,EAAQwB,KAAMhB,GAGhB,OAAKiB,EAAY3B,GAET,IAAIA,EAAE4B,YAAaC,EAAU7B,GAAK8B,EAAS9B,GAAKG,EAAOD,EAAS6B,EAAW/B,GAAKK,EAAK,CAC3F2B,UAAY,IAGP,IAAIhC,EAAE4B,YAAaC,EAAU7B,GAAK8B,EAAS9B,GAAKG,EAAOD,EAAS6B,EAAW/B,GAAKK,EACxF"}